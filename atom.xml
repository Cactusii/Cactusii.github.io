<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cactusii.github.io/</id>
    <title>Cactuii&apos;s Blog</title>
    <updated>2020-09-28T05:38:46.189Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cactusii.github.io/"/>
    <link rel="self" href="https://cactusii.github.io/atom.xml"/>
    <subtitle>我咸甚，此鱼何能及我也！</subtitle>
    <logo>https://cactusii.github.io/images/avatar.png</logo>
    <icon>https://cactusii.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Cactuii&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[【算法】数学]]></title>
        <id>https://cactusii.github.io/post/suan-fa-shu-xue/</id>
        <link href="https://cactusii.github.io/post/suan-fa-shu-xue/">
        </link>
        <updated>2020-09-28T05:21:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="分解质因数">分解质因数</h2>
<pre><code class="language-c++">void primeFactor(int n)
{
    for(int i=2;i&lt;sqrt(n);i++)
    {
        while(n%i==0) //输出所有可以约去的数
        {
            cout&lt;&lt;i&lt;&lt;&quot; &quot;;
            n/=i;
        }
    }
}
</code></pre>
<p>一个自然数的约数个数是它各质因数的次数分别加1相乘的积。<br>
例：18的因数有：1，2，3，6，9，18。而其质因数有18=2×2×3。<br>
<img src="https://cactusii.github.io//post-images/1601271024765.jpg" alt="" loading="lazy"><br>
即(1+1) * (2+1)=6个。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java技能树]]></title>
        <id>https://cactusii.github.io/post/java-ji-neng-shu/</id>
        <link href="https://cactusii.github.io/post/java-ji-neng-shu/">
        </link>
        <updated>2020-09-27T10:15:56.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1601201773805.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】二叉树]]></title>
        <id>https://cactusii.github.io/post/shu-ju-jie-gou-er-cha-shu/</id>
        <link href="https://cactusii.github.io/post/shu-ju-jie-gou-er-cha-shu/">
        </link>
        <updated>2020-09-23T06:30:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="二叉树的存储">二叉树的存储</h2>
<h3 id="1-顺序存储结构">1. 顺序存储结构</h3>
<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600843894170.jpg" alt="" loading="lazy"></figure>
<h3 id="2链式存储">2.链式存储</h3>
<figure data-type="image" tabindex="2"><img src="https://cactusii.github.io//post-images/1600843945025.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-c++">typedef struct node
{
    int data;
    struct node *lchild, *rchild;
}Bitree;
</code></pre>
<h2 id="二叉树的访问">二叉树的访问</h2>
<h3 id="先序访问">先序访问</h3>
<pre><code class="language-c++">void preOrderTraveral(Bitree *node) //递归
{
    if(node == NULL)
    {
        return;
    }
    printf(&quot;%d &quot;,node-&gt;data);
    preOrderTraveral(node-&gt;lchild);
    preOrderTraveral(node-&gt;rchild);
}


void _preOrderTraveral(Bitree *node) //非递归
{
    stack&lt;Bitree*&gt; s;
    Bitree *tmp_node = node;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL)
        {
            printf(&quot;%d &quot;,tmp_node-&gt;data);
            s.push(tmp_node);
            tmp_node = tmp_node-&gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            tmp_node = tmp_node-&gt;rchild;
        }
    }
}
</code></pre>
<h3 id="中序访问">中序访问</h3>
<pre><code class="language-c++">void inOrderTraveral(Bitree *node)
{
    if(node == NULL)
    {
        return;
    }
    inOrderTraveral(node-&gt;lchild);
    printf(&quot;%d &quot;,node-&gt;data);
    inOrderTraveral(node-&gt;rchild);
}


void _inOrderTraveral(Bitree *node)
{
    stack&lt;Bitree*&gt; s;
    Bitree *tmp_node = node;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL)
        {
            s.push(tmp_node);
            tmp_node = tmp_node-&gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            printf(&quot;%d &quot;,tmp_node-&gt;data);
            tmp_node = tmp_node-&gt;rchild;
        }
    }
}
</code></pre>
<h3 id="后序访问">后序访问</h3>
<pre><code class="language-c++">void postOrderTraveral(Bitree *node)
{
    if(node == NULL)
    {
        return;
    }
    postOrderTraveral(node-&gt;lchild);
    postOrderTraveral(node-&gt;rchild);
    printf(&quot;%d &quot;,node-&gt;data);
}


void _postOrderTraveral(Bitree *node)
{
    stack&lt;Bitree*&gt; s;
    Bitree *tmp_node = node, *lastVisit = NULL;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL) //左节点入栈
        {
            s.push(tmp_node);
            tmp_node = tmp_node-&gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            if(tmp_node-&gt;rchild==NULL || tmp_node-&gt;rchild==lastVisit) //此节点右孩子为空或者已访问过，那么访问此节点
            {
                printf(&quot;%d &quot;,tmp_node-&gt;data);
                lastVisit = tmp_node;
                tmp_node = NULL;
            }
            else
            {
                s.push(tmp_node);
                tmp_node = tmp_node-&gt;rchild;
            }
        }
    }
}
</code></pre>
<p>层次遍历<br>
二叉树的层次遍历基于广度优先搜索，<font color='red'>在访问第n层时，一定会访问完第n-1层</font>。</p>
<pre><code class="language-c++">void levelOrder(Bitree *root)
{
    if(!root) return;
    queue&lt;Bitree *&gt; q;
    q.push(root);
    while(!q.empty())
    {
        Bitree tmp = q.front();
        q.pop();
        printf(&quot;%d&quot;,tmp-&gt;data);
        if(tmp-&gt;lchild) q.push(tmp.lchild);
        if(tmp-&gt;rchild) q.push(tmp.rchild);
    }
}
</code></pre>
<h2 id="0二叉搜索树">0二叉搜索树</h2>
<p>左子树的所有结点值均小于根结点的值；右子树的所有结点值均大于根结点的值；左子树也是二叉搜索树。</p>
<h3 id="二叉搜索树的构建">二叉搜索树的构建</h3>
<pre><code class="language-c++">typedef struct TreeNode
{
    int val;
    struct TreeNode *lchild, *rchild;
}TreeNode;

void Create(TreeNode *root, int tmp)
{
    if(!root)
    {
        root = (TreeNode *)malloc(sizeof(TreeNode));
        root-&gt;val = tmp;
        return;
    }
    if(root-&gt;val &lt; tmp)
        Create(root-&gt;lchild,tmp);
    else
        Create(root-&gt;rchild,tmp);
}
</code></pre>
<h3 id="二叉搜索树结点的删除">二叉搜索树结点的删除</h3>
<ol>
<li>如果删除的结点只有左孩子或者只有有孩子，那么直接删除，然后把其孩子加到父节点上。<br>
<img src="https://cactusii.github.io//post-images/1600996986954.jpg" alt="" loading="lazy"></li>
<li>如果删除的结点有左孩子和有孩子，那么删除此节点后，需要将其左子树的最大结点或者右子树的最小节点替换上来。<img src="https://cactusii.github.io//post-images/1600997012992.jpg" alt="" loading="lazy"></li>
</ol>
<h3 id="找到二叉搜索树两个结点的最近的双亲结点">找到二叉搜索树两个结点的最近的双亲结点</h3>
<p>利用二叉搜索树的特点，遍历整个二叉树，如果两个节点都小于当前遍历结点，那么递归到其左子树；如果两个结点都大于当前遍历结点，那么递归到其右子树上，如果一个大于一个小于当前遍历结点，那么此结点即为其最近的双亲结点。</p>
<pre><code class="language-c++">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)
        return lowestCommonAncestor(root-&gt;left,p,q);
    else if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)
        return lowestCommonAncestor(root-&gt;right,p,q);
    return root;
}
</code></pre>
<p>二叉搜索树的中序遍历是递增顺序</p>
<h2 id="由中序和后序还原二叉树">由中序和后序还原二叉树</h2>
<ol>
<li>后序中右起第一位3肯定是根结点，我们可以据此找到中序中根结点的位置rootin；</li>
<li>中序中根结点左边就是左子树结点，右边就是右子树结点，即[左子树结点，根结点，右子树结点]，我们就可以得出左子树结点个数为int left_count = tmp - inleft;；</li>
<li>后序中结点分布应该是：[左子树结点，右子树结点，根结点]；</li>
<li>根据前一步确定的左子树个数，可以确定后序中左子树结点和右子树结点的范围；</li>
<li>如果我们要前序遍历生成二叉树的话，下一层递归应该是：</li>
</ol>
<ul>
<li>左子树：root-&gt;left = pre_order(中序左子树范围，后序左子树范围，中序序列，后序序列);；</li>
<li>右子树：root-&gt;right = pre_order(中序右子树范围，后序右子树范围，中序序列，后序序列);。</li>
</ul>
<ol start="6">
<li>每一层递归都要返回当前根结点root；</li>
</ol>
<pre><code class="language-c++">TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
    TreeNode *root = pre_order(0,inorder.size()-1, 0,postorder.size()-1, inorder, postorder);
    return root;
}

TreeNode *pre_order(int inleft, int inright, int postleft, int postright, vector&lt;int&gt; &amp;inorder, vector&lt;int&gt;&amp; postorder)
{
    if(inleft&gt;inright) return NULL;
    TreeNode *root = new TreeNode(postorder[postright]);
    int tmp = inleft;
    while(inorder[tmp]!=postorder[postright]) tmp++;
    int left_count = tmp - inleft; //左子树的结点个数
    root-&gt;left = pre_order(inleft,tmp-1,postleft,postleft+left_count-1,inorder,postorder);
    root-&gt;right = pre_order(tmp+1,inright,postleft+left_count,postright-1,inorder,postorder);
    return root;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】并查集]]></title>
        <id>https://cactusii.github.io/post/shu-ju-jie-gou-bing-cha-ji/</id>
        <link href="https://cactusii.github.io/post/shu-ju-jie-gou-bing-cha-ji/">
        </link>
        <updated>2020-09-22T02:23:07.000Z</updated>
        <content type="html"><![CDATA[<p>并查集主要用于处理一些不相交集合的问题。</p>
<p>每个集合包含一个或多个元素，并且有一个代表元素。对于给定一个元素，可以快速找到其所属集合的代表元素，这样判断两个元素是否属于同一集合，只需要判断二者所属集合的代表元素是否一致即可。</p>
<p>如果要合并两个集合，只需要将其中一个集合的代表元素设为另一个集合的代表元素即可。</p>
<hr>
<p><strong>涉及到的主要操作有两个</strong></p>
<ol>
<li>合并：把两个元素所属集合合并（前提是两个集合不相交）</li>
</ol>
<pre><code class="language-c">void join(int a, int b)
{
    int tmpa,tmpb;
    tmpa = find_root(a);
    tmpb = find_root(b);
    if(tmpa!=tmpb)
        root[tmpa] = tmpb;
}
</code></pre>
<ol start="2">
<li>查找根（代表元素）：找到某一个元素的所属集合的根。</li>
</ol>
<pre><code class="language-c">int find_root(int x)
{
    while(x!=root[x])
        x = root[x];
    return x;
}

//root[x]=y表示x的根是y，初始化时，每个元素的根都是自己
</code></pre>
<p><strong>路径压缩</strong><br>
查找根最坏的一种情况是一条常常的链，这时候查找的效率会大大降低，此时可以使用路径压缩，即将每个元素直接指向根节点 ，如下图。<br>
<img src="https://cactusii.github.io//post-images/1600744618773.jpg" alt="" loading="lazy"></p>
<p>我们可以在查找的过程中把每个元素的父节点直接设成根节点。</p>
<pre><code class="language-c">int find_root(int x)
{
    int root_of_x = x; //根节点
   
    while(root_of_x != root[root_of_x])
        root_of_x = root[root_of_x];

    while(x != root[x]) //将每个子节点的父节点都换成根节点
    {
        int tmp = x;
        x = root[x];
        root[tmp] = root_of_x;
    }
    return root_of_x;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】链表的存储]]></title>
        <id>https://cactusii.github.io/post/shu-ju-jie-gou-lian-biao-de-cun-chu/</id>
        <link href="https://cactusii.github.io/post/shu-ju-jie-gou-lian-biao-de-cun-chu/">
        </link>
        <updated>2020-09-22T00:33:29.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600735871236.png" alt="" loading="lazy"></figure>
<h2 id="定义链表结构体">定义链表结构体</h2>
<pre><code class="language-c">typedef struct ListNode
{
    int val;
    struct ListNode *next;
}ListNode;
</code></pre>
<h2 id="遍历链表">遍历链表</h2>
<pre><code class="language-c">void print(ListNode *head)
{
    for(ListNode *cursor = head; cursor; cursor = cursor-&gt;next)
    {
        printf(&quot;%d-&gt;&quot;,cursor-&gt;val);
    }
}
</code></pre>
<h2 id="尾部插入">尾部插入</h2>
<pre><code class="language-c">void lpush_back(ListNode *head, int val)
{
    ListNode *node = (ListNode*)malloc(sizeof(ListNode));
    ListNode *cursor = head;
    node-&gt;val = val;
    while(cursor-&gt;next) cursor = cursor-&gt;next;
    cursor-&gt;next = node;
}
</code></pre>
<h2 id="头部插入">头部插入</h2>
<pre><code class="language-c">void lpush_front(ListNode **head, int val)
{
    ListNode *node = (ListNode*)malloc(sizeof(ListNode));
    node-&gt;val = val;
    node-&gt;next =*head;
    *head = node;
}
</code></pre>
<h2 id="头部删除">头部删除</h2>
<h2 id="删除指定节点">删除指定节点</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】排序算法]]></title>
        <id>https://cactusii.github.io/post/pai-xu-suan-fa/</id>
        <link href="https://cactusii.github.io/post/pai-xu-suan-fa/">
        </link>
        <updated>2020-09-21T14:51:59.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600700055304.png" alt="" loading="lazy"></figure>
<h2 id="稳定排序">稳定排序</h2>
<h3 id="1直接插入排序-on2">1.直接插入排序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3>
<pre><code class="language-c++">void insSort(int *arr,int n)
{
    for(int i=0;i&lt;n;i++)
    {
        int tmp=arr[i];
        int j=i-1;
        while(j&gt;=0&amp;&amp;tmp&lt;arr[j])
        {
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=tmp;
    }
}
</code></pre>
<h3 id="2冒泡排序-on2">2.冒泡排序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3>
<pre><code class="language-c++">void bubSort(int *arr,int n)
{
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;n-i-1;j++)
            if(arr[j]&gt;arr[j+1])
                swap(arr[j],arr[j+1]);
}
</code></pre>
<h3 id="3二路归并排序">3.二路归并排序</h3>
<p>按照分治思想，将序列分为若干子序列，子序列有序，然后再将子序列合并为整体有序序列。</p>
<h3 id="4基数排序">4.基数排序</h3>
<p>桶子排序，按照基数对整个序列进行多次的排序。</p>
<h2 id="不稳定排序">不稳定排序</h2>
<h3 id="5选择排序">5.选择排序</h3>
<pre><code class="language-c++">void selSort(int *arr,int n)
{
    for(int i=0;i&lt;n;i++)
    {
        int MIN_index = i;
        for(int j=i;j&lt;n;j++)
            if(arr[MIN_index]&gt;arr[j]) MIN_index=j;
        swap(arr[MIN_index],arr[i]);
    }
}

</code></pre>
<h3 id="6快速排序">6.快速排序</h3>
<p>挖坑填坑的过程。</p>
<pre><code class="language-c++">void quiSort(int *arr,int l,int r)
{
    if(l&gt;=r) return;
    int base=arr[l];
    int i=l,j=r;
    while(i&lt;j)
    {
        while(arr[j]&gt;=base&amp;&amp;i&lt;j) j--;
        if(i&lt;j) arr[i++]=arr[j];
        while(arr[i]&lt;base&amp;&amp;i&lt;j) i++;
        if(i&lt;j) arr[j--]=arr[i];
    }
    arr[i]=base;
    quiSort(arr,l,i-1);
    quiSort(arr,i+1,r);
}

</code></pre>
<h3 id="7希尔排序">7.希尔排序</h3>
<p>希尔排序就是升级版的插入排序。</p>
<pre><code class="language-c++">void sheSort(int *arr,int n)
{
    int gap=n/2;
    while(gap&gt;=1)
    {
        for(int i=gap; i&lt;n; i++)
        {
            int j=i-gap;
            int tmp=arr[i];
            while(j&gt;=0&amp;&amp;tmp&lt;arr[j])
            {
                arr[j+gap]=arr[j];
                j-=gap;
            }
            arr[j+gap]=tmp;
        }
        gap/=2;
    }
}

</code></pre>
<h3 id="8堆排序">8.堆排序</h3>
<p>不断拿出堆顶结点然后调整大(小)顶堆的过程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【C++】没用的小知识]]></title>
        <id>https://cactusii.github.io/post/cmei-yong-de-xiao-zhi-shi/</id>
        <link href="https://cactusii.github.io/post/cmei-yong-de-xiao-zhi-shi/">
        </link>
        <updated>2020-09-21T14:42:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="c编译器">C++编译器</h2>
<p>C/C++常用的编译器是由GNU开发的GCC编译器。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【C++】面向对象基基基基础]]></title>
        <id>https://cactusii.github.io/post/cji-ji-ji-ji-chu-mian-xiang-dui-xiang/</id>
        <link href="https://cactusii.github.io/post/cji-ji-ji-ji-chu-mian-xiang-dui-xiang/">
        </link>
        <updated>2020-09-21T09:27:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1构造函数析构函数类和对象">1.构造函数&amp;析构函数（类和对象）</h2>
<h2 id="2基类派生类继承">2.基类&amp;派生类（继承）</h2>
<h2 id="3函数重载虚函数多态">3.函数重载&amp;虚函数（多态）</h2>
<h2 id="4抽象">4.抽象</h2>
<h2 id="5接口抽象类">5.接口（抽象类）</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浮点数的存储方法以及python的Decimal]]></title>
        <id>https://cactusii.github.io/post/fu-dian-shu-de-cun-chu-fang-fa-yi-ji-python-de-decimal/</id>
        <link href="https://cactusii.github.io/post/fu-dian-shu-de-cun-chu-fang-fa-yi-ji-python-de-decimal/">
        </link>
        <updated>2020-09-19T02:06:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="浮点数的存储方式">浮点数的存储方式</h2>
<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600483237666.jpg" alt="" loading="lazy"></figure>
<h2 id="decimaldecimal">decimal.Decimal</h2>
<p>python中的decimal.Decimal类型可以非常精确地存储在计算机中，其优于float类型。<br>
用法：</p>
<pre><code class="language-python">from decimal import Decimal

# 字符串/浮点数转换为Decimal
Decimal('1.11')
# &gt;&gt;Decimal('1.11')
Decimal(1.11)
# &gt;&gt;Decimal('1.1100000000000000976996261670137755572795867919921875')

# 四舍五入
Decimal('50.5679').quantize(Decimal('0.00'))
# &gt;&gt;Decimal('50.57')

# Decimal 结果转化为string
str(Decimal('3.40').quantize(Decimal('0.0')))
# &gt;&gt;'3.4'

</code></pre>
<p>将浮点数以二进制输出：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
	float fnum = 1;
	int i;
	int * p = (int *)&amp;fnum;//定义一个指向fnum的指针
        int x=0;//设置flag变量
	while (fnum != 0)//以0作为输入结束标志
	{
		printf(&quot;input a num: &quot;);
		x=scanf(&quot;%f&quot;, &amp;fnum);
                if(!x)//判断是否输入成功
                {
                       printf(&quot;wrong\n&quot;);
                       fflush(stdin);//清空输入流，不然会死循环
                       continue;
                }
		for (i = 31; i &gt;= 0; i--)
		{
                      /*将1左移i位，通过与运算判断第i位是否为1*/
                      printf(&quot;%d&quot;, (*p &amp; (1 &lt;&lt; i) ? 1: 0));
                      /*控制空格输入*/
                      if(i==31||i==23)
                           printf(&quot;  &quot;);
                      if(i==27||i==19||i==15||i==11||i==7||i==3)
                           printf(&quot; &quot;);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编译型、解释型语言]]></title>
        <id>https://cactusii.github.io/post/bian-yi-xing-jie-shi-xing-yu-yan/</id>
        <link href="https://cactusii.github.io/post/bian-yi-xing-jie-shi-xing-yu-yan/">
        </link>
        <updated>2020-09-16T12:02:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="编译型语言">编译型语言</h2>
<p>需要通过编译器将源代码编译成机器码，之后才能执行的语言。一般需经过编译、链接这两个步骤。编译时把源代码编译成机器码，链接时把各个模块的机器码和依赖库串联起来生成可执行文件。</p>
<p><strong>优点：</strong> 编译一次，运行时不需要编译，所以执行效率高，可以脱离语言环境独立运行（因为已经编译成了基于此机器系统的机器指令码）。大部分软件产品都是以目标程序形式发行给用户，不仅便于直接执行，而且又使得他人难以盗用其中的技术。</p>
<p><strong>缺点：</strong> 编译之后如果需要修改则需要再次编译，由于编译执行的语言直接跟CPU的指令集打交道，具有很强的指令依赖性和系统依赖性，因此在不同操作系统之间移植会出现问题，需要根据运行的操作系统环境编译不同的可执行文件。</p>
<p><strong>代表语言：</strong> C、C++、Pascal、Object-C</p>
<h2 id="解释型语言">解释型语言</h2>
<p>解释型语言的程序不需要编译，相比编译型语言省了道工序，解释型语言在运行程序时才逐行进行翻译。（边执行边翻译）</p>
<p><strong>优点：</strong> 有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。</p>
<p><strong>缺点：</strong> 每次运行的时候都要解释一遍，因此运行速度会稍慢。</p>
<p><strong>代表语言：</strong> JavaScript、Python、Erlang、PHP、Perl、Ruby</p>
<p>脚本语言是解释型语言。</p>
<h2 id="混合型语言">混合型语言</h2>
<p>混合型语言在编译的时候不是直接编译成机器码，而是中间码。<br>
例如java将程序翻译成一种中间代码字节码，可以被java解释器解释的独立于平台的代码。通过解释器，每条java字节指令被分析，然后运行在计算机上。只需编译一次，程序运行时解释执行。</p>
<p>可以把java字节码看作运行在java虚拟机上的机器代码指令。每种java解释器，不管是java 开发工具还是可以运行java小应用程序的web浏览器，都是一种java VM的实例，java VM也可以由硬件实现。</p>
<p>我们都知道java语言一个非常重要的特点是与平台无关性，而java VM是实现这一特点的关键。</p>
]]></content>
    </entry>
</feed>