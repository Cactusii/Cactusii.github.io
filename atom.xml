<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cactusii.github.io/</id>
    <title>Cactuii&apos;s Blog</title>
    <updated>2020-10-16T07:01:12.468Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cactusii.github.io/"/>
    <link rel="self" href="https://cactusii.github.io/atom.xml"/>
    <subtitle>我咸甚，此鱼何能及我也！</subtitle>
    <logo>https://cactusii.github.io/images/avatar.png</logo>
    <icon>https://cactusii.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Cactuii&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[威胁情报]]></title>
        <id>https://cactusii.github.io/post/wei-xie-qing-bao/</id>
        <link href="https://cactusii.github.io/post/wei-xie-qing-bao/">
        </link>
        <updated>2020-10-16T05:37:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="是什么">是什么</h2>
<p>情报是线索，威胁情报是为了还原已发生的攻击和预测未发生的攻击所需要的一切线索。</p>
<p>既然企业需要收集情报来完成帮助自己提高抵御威胁的能力，那么在网络空间安全中，重要的情报就是IP（是否连接了恶意的IP）、文件（是否下载了恶意的文件）、域名（是否连接了恶意的域名）等了。</p>
<h2 id="包含什么">包含什么</h2>
<ul>
<li>恶意IP</li>
<li>域名/网站</li>
<li>文件哈希（对恶意软件生成一个指纹）</li>
<li>受害产业</li>
</ul>
<h2 id="行业标准和规范">行业标准和规范</h2>
<p>-</p>
<h2 id="情报来源">情报来源</h2>
<p>如果主要关注情报中的域名、IP、URL等数据，主要来源有两类：</p>
<ul>
<li>开源的黑名单。例如<a href="http://iplists.firehol.org/">FireHOL</a>、<a href="https://isc.sans.edu/">sans.edu</a>。这些黑名单更新迅速、可信度高，是我们所关注的信息的一个很好的来源。且十分容易处理。</li>
<li>安全咨询类网站上的文章。在这些文章中往往包含了很多的特定主题下的IoC信息，这些信息具有针对性强的特点，即一个IP或域名可以对应到某一具体的事件。这也是威胁情报收集中非常重要的一类来源，但其最大的问题是这些信息一般都在文章中出现，其间夹杂了大量的冗余信息，使得提取这些数据具有一定的困难。</li>
</ul>
<h2 id="威胁指标">威胁指标</h2>
<p>威胁指标是一个实体，该指标表示遭到某种攻击或威胁的可能性。最常见的类型是文件哈希/签名，域名和 IP 地址的声誉度，这些都能与攻击进行关联。<br>
哈希文件是对蠕虫、木马、键盘记录程序和其他类型的恶意程序的唯一标识，MD5 或 SHA-1 可以生成一个独特的指纹，可以利用这串独有的字符串来标定恶意软件。同样的，网站、IP 地址、甚至是传播恶意软件独特的 URL，都会通过受感染的用户把风险带入整个网络。跟踪恶意网站，完善黑名单的 IP 列表，使用哈希字符串来识别恶意软件，阻止它们入侵你的技术基础设施。与风险相关的恶意网站/ IP 地址：</p>
<ul>
<li>垃圾邮件和网络钓鱼</li>
<li>恶意软件和间谍程序</li>
<li>匿名代理和 P2P 网络</li>
<li>暗网 IP 地址（使用 TOR）</li>
<li>管理僵尸网络的 C&amp;C 服务器</li>
</ul>
<h2 id="难点">难点</h2>
<p>网络中存在的情报结构不同、关注方向不同、可信度不同、情报内容不同、情报的来源也是千奇百怪，因此在现阶段无法统一有效的提取出威胁情报中能够应用的关键信息。</p>
<h2 id="威胁情报平台">威胁情报平台</h2>
<ol>
<li><a href="https://x.threatbook.cn">微步在线</a><br>
<img src="https://cactusii.github.io//post-images/1602828155600.png" alt="" loading="lazy"></li>
<li><a href="https://ti.360.cn/">360威胁情报中心</a><br>
<img src="https://cactusii.github.io//post-images/1602828291980.png" alt="" loading="lazy"></li>
<li><a href="https://exchange.xforce.ibmcloud.com/">IBM X-Force Exchange</a><br>
<img src="https://cactusii.github.io//post-images/1602828218300.png" alt="" loading="lazy"></li>
</ol>
<h2 id="开源项目">开源项目</h2>
<ol>
<li><a href="https://github.com/NewBee119/Ti_Collector">Ti_Collector</a></li>
</ol>
<p>参考：<a href="https://www.freebuf.com/sectool/152201.html">1一个爬虫的小例子</a>、<a href="https://blog.csdn.net/tan6600/article/details/52138282?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">2</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【算法】数学]]></title>
        <id>https://cactusii.github.io/post/suan-fa-shu-xue/</id>
        <link href="https://cactusii.github.io/post/suan-fa-shu-xue/">
        </link>
        <updated>2020-09-28T05:21:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="分解质因数">分解质因数</h2>
<pre><code class="language-c++">void primeFactor(int n)
{
    for(int i=2;i&lt;sqrt(n);i++)
    {
        while(n%i==0) //输出所有可以约去的数
        {
            cout&lt;&lt;i&lt;&lt;&quot; &quot;;
            n/=i;
        }
    }
}
</code></pre>
<p>一个自然数的约数个数是它各质因数的次数分别加1相乘的积。<br>
例：18的因数有：1，2，3，6，9，18。而其质因数有18=2×2×3。<br>
<img src="https://cactusii.github.io//post-images/1601271024765.jpg" alt="" loading="lazy"><br>
即(1+1) * (2+1)=6个。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java技能树]]></title>
        <id>https://cactusii.github.io/post/java-ji-neng-shu/</id>
        <link href="https://cactusii.github.io/post/java-ji-neng-shu/">
        </link>
        <updated>2020-09-27T10:15:56.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1601201773805.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】二叉树]]></title>
        <id>https://cactusii.github.io/post/shu-ju-jie-gou-er-cha-shu/</id>
        <link href="https://cactusii.github.io/post/shu-ju-jie-gou-er-cha-shu/">
        </link>
        <updated>2020-09-23T06:30:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="二叉树的存储">二叉树的存储</h2>
<h3 id="1-顺序存储结构">1. 顺序存储结构</h3>
<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600843894170.jpg" alt="" loading="lazy"></figure>
<h3 id="2链式存储">2.链式存储</h3>
<figure data-type="image" tabindex="2"><img src="https://cactusii.github.io//post-images/1600843945025.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-c++">typedef struct node
{
    int data;
    struct node *lchild, *rchild;
}Bitree;
</code></pre>
<h2 id="二叉树的访问">二叉树的访问</h2>
<h3 id="先序访问">先序访问</h3>
<pre><code class="language-c++">void preOrderTraveral(Bitree *node) //递归
{
    if(node == NULL)
    {
        return;
    }
    printf(&quot;%d &quot;,node-&gt;data);
    preOrderTraveral(node-&gt;lchild);
    preOrderTraveral(node-&gt;rchild);
}


void _preOrderTraveral(Bitree *node) //非递归
{
    stack&lt;Bitree*&gt; s;
    Bitree *tmp_node = node;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL)
        {
            printf(&quot;%d &quot;,tmp_node-&gt;data);
            s.push(tmp_node);
            tmp_node = tmp_node-&gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            tmp_node = tmp_node-&gt;rchild;
        }
    }
}
</code></pre>
<h3 id="中序访问">中序访问</h3>
<pre><code class="language-c++">void inOrderTraveral(Bitree *node)
{
    if(node == NULL)
    {
        return;
    }
    inOrderTraveral(node-&gt;lchild);
    printf(&quot;%d &quot;,node-&gt;data);
    inOrderTraveral(node-&gt;rchild);
}


void _inOrderTraveral(Bitree *node)
{
    stack&lt;Bitree*&gt; s;
    Bitree *tmp_node = node;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL)
        {
            s.push(tmp_node);
            tmp_node = tmp_node-&gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            printf(&quot;%d &quot;,tmp_node-&gt;data);
            tmp_node = tmp_node-&gt;rchild;
        }
    }
}
</code></pre>
<h3 id="后序访问">后序访问</h3>
<pre><code class="language-c++">void postOrderTraveral(Bitree *node)
{
    if(node == NULL)
    {
        return;
    }
    postOrderTraveral(node-&gt;lchild);
    postOrderTraveral(node-&gt;rchild);
    printf(&quot;%d &quot;,node-&gt;data);
}


void _postOrderTraveral(Bitree *node)
{
    stack&lt;Bitree*&gt; s;
    Bitree *tmp_node = node, *lastVisit = NULL;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL) //左节点入栈
        {
            s.push(tmp_node);
            tmp_node = tmp_node-&gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            if(tmp_node-&gt;rchild==NULL || tmp_node-&gt;rchild==lastVisit) //此节点右孩子为空或者已访问过，那么访问此节点
            {
                printf(&quot;%d &quot;,tmp_node-&gt;data);
                lastVisit = tmp_node;
                tmp_node = NULL;
            }
            else
            {
                s.push(tmp_node);//如果有右孩子并且每访问过，再将此结点入栈
                tmp_node = tmp_node-&gt;rchild;
            }
        }
    }
}
</code></pre>
<p>层次遍历<br>
二叉树的层次遍历基于广度优先搜索，<font color='red'>在访问第n层时，一定会访问完第n-1层</font>。</p>
<pre><code class="language-c++">void levelOrder(Bitree *root)
{
    if(!root) return;
    queue&lt;Bitree *&gt; q;
    q.push(root);
    while(!q.empty())
    {
        Bitree tmp = q.front();
        q.pop();
        printf(&quot;%d&quot;,tmp-&gt;data);
        if(tmp-&gt;lchild) q.push(tmp.lchild);
        if(tmp-&gt;rchild) q.push(tmp.rchild);
    }
}
</code></pre>
<h2 id="0二叉搜索树">0二叉搜索树</h2>
<p>左子树的所有结点值均小于根结点的值；右子树的所有结点值均大于根结点的值；左子树也是二叉搜索树。</p>
<h3 id="二叉搜索树的构建">二叉搜索树的构建</h3>
<pre><code class="language-c++">typedef struct TreeNode
{
    int val;
    struct TreeNode *lchild, *rchild;
}TreeNode;

void Create(TreeNode *root, int tmp)
{
    if(!root)
    {
        root = (TreeNode *)malloc(sizeof(TreeNode));
        root-&gt;val = tmp;
        return;
    }
    if(root-&gt;val &lt; tmp)
        Create(root-&gt;lchild,tmp);
    else
        Create(root-&gt;rchild,tmp);
}
</code></pre>
<h3 id="二叉搜索树结点的删除">二叉搜索树结点的删除</h3>
<ol>
<li>如果删除的结点只有左孩子或者只有有孩子，那么直接删除，然后把其孩子加到父节点上。<br>
<img src="https://cactusii.github.io//post-images/1600996986954.jpg" alt="" loading="lazy"></li>
<li>如果删除的结点有左孩子和有孩子，那么删除此节点后，需要将其左子树的最大结点或者右子树的最小节点替换上来。<img src="https://cactusii.github.io//post-images/1600997012992.jpg" alt="" loading="lazy"></li>
</ol>
<h3 id="找到二叉搜索树两个结点的最近的双亲结点">找到二叉搜索树两个结点的最近的双亲结点</h3>
<p>利用二叉搜索树的特点，遍历整个二叉树，如果两个节点都小于当前遍历结点，那么递归到其左子树；如果两个结点都大于当前遍历结点，那么递归到其右子树上，如果一个大于一个小于当前遍历结点，那么此结点即为其最近的双亲结点。</p>
<pre><code class="language-c++">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)
        return lowestCommonAncestor(root-&gt;left,p,q);
    else if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)
        return lowestCommonAncestor(root-&gt;right,p,q);
    return root;
}
</code></pre>
<p>二叉搜索树的中序遍历是递增顺序</p>
<h2 id="由中序和后序还原二叉树">由中序和后序还原二叉树</h2>
<ol>
<li>后序中右起第一位3肯定是根结点，我们可以据此找到中序中根结点的位置rootin；</li>
<li>中序中根结点左边就是左子树结点，右边就是右子树结点，即[左子树结点，根结点，右子树结点]，我们就可以得出左子树结点个数为int left_count = tmp - inleft;；</li>
<li>后序中结点分布应该是：[左子树结点，右子树结点，根结点]；</li>
<li>根据前一步确定的左子树个数，可以确定后序中左子树结点和右子树结点的范围；</li>
<li>如果我们要前序遍历生成二叉树的话，下一层递归应该是：</li>
</ol>
<ul>
<li>左子树：root-&gt;left = pre_order(中序左子树范围，后序左子树范围，中序序列，后序序列);；</li>
<li>右子树：root-&gt;right = pre_order(中序右子树范围，后序右子树范围，中序序列，后序序列);。</li>
</ul>
<ol start="6">
<li>每一层递归都要返回当前根结点root；</li>
</ol>
<pre><code class="language-c++">TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
    TreeNode *root = pre_order(0,inorder.size()-1, 0,postorder.size()-1, inorder, postorder);
    return root;
}

TreeNode *pre_order(int inleft, int inright, int postleft, int postright, vector&lt;int&gt; &amp;inorder, vector&lt;int&gt;&amp; postorder)
{
    if(inleft&gt;inright) return NULL;
    TreeNode *root = new TreeNode(postorder[postright]);
    int tmp = inleft;
    while(inorder[tmp]!=postorder[postright]) tmp++;
    int left_count = tmp - inleft; //左子树的结点个数
    root-&gt;left = pre_order(inleft,tmp-1,postleft,postleft+left_count-1,inorder,postorder);
    root-&gt;right = pre_order(tmp+1,inright,postleft+left_count,postright-1,inorder,postorder);
    return root;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】并查集]]></title>
        <id>https://cactusii.github.io/post/shu-ju-jie-gou-bing-cha-ji/</id>
        <link href="https://cactusii.github.io/post/shu-ju-jie-gou-bing-cha-ji/">
        </link>
        <updated>2020-09-22T02:23:07.000Z</updated>
        <content type="html"><![CDATA[<p>并查集主要用于处理一些不相交集合的问题。</p>
<p>每个集合包含一个或多个元素，并且有一个代表元素。对于给定一个元素，可以快速找到其所属集合的代表元素，这样判断两个元素是否属于同一集合，只需要判断二者所属集合的代表元素是否一致即可。</p>
<p>如果要合并两个集合，只需要将其中一个集合的代表元素设为另一个集合的代表元素即可。</p>
<hr>
<p><strong>涉及到的主要操作有两个</strong></p>
<ol>
<li>合并：把两个元素所属集合合并（前提是两个集合不相交）</li>
</ol>
<pre><code class="language-c">void join(int a, int b)
{
    int tmpa,tmpb;
    tmpa = find_root(a);
    tmpb = find_root(b);
    if(tmpa!=tmpb)
        root[tmpa] = tmpb;
}
</code></pre>
<ol start="2">
<li>查找根（代表元素）：找到某一个元素的所属集合的根。</li>
</ol>
<pre><code class="language-c">int find_root(int x)
{
    while(x!=root[x])
        x = root[x];
    return x;
}

//root[x]=y表示x的根是y，初始化时，每个元素的根都是自己
</code></pre>
<p><strong>路径压缩</strong><br>
查找根最坏的一种情况是一条常常的链，这时候查找的效率会大大降低，此时可以使用路径压缩，即将每个元素直接指向根节点 ，如下图。<br>
<img src="https://cactusii.github.io//post-images/1600744618773.jpg" alt="" loading="lazy"></p>
<p>我们可以在查找的过程中把每个元素的父节点直接设成根节点。</p>
<pre><code class="language-c">int find_root(int x)
{
    int root_of_x = x; //根节点
   
    while(root_of_x != root[root_of_x])
        root_of_x = root[root_of_x];

    while(x != root[x]) //将每个子节点的父节点都换成根节点
    {
        int tmp = x;
        x = root[x];
        root[tmp] = root_of_x;
    }
    return root_of_x;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】链表的存储]]></title>
        <id>https://cactusii.github.io/post/shu-ju-jie-gou-lian-biao-de-cun-chu/</id>
        <link href="https://cactusii.github.io/post/shu-ju-jie-gou-lian-biao-de-cun-chu/">
        </link>
        <updated>2020-09-22T00:33:29.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600735871236.png" alt="" loading="lazy"></figure>
<h2 id="定义链表结构体">定义链表结构体</h2>
<pre><code class="language-c">typedef struct ListNode
{
    int val;
    struct ListNode *next;
}ListNode;
</code></pre>
<h2 id="遍历链表">遍历链表</h2>
<pre><code class="language-c">void print(ListNode *head)
{
    for(ListNode *cursor = head; cursor; cursor = cursor-&gt;next)
    {
        printf(&quot;%d-&gt;&quot;,cursor-&gt;val);
    }
}
</code></pre>
<h2 id="尾部插入">尾部插入</h2>
<pre><code class="language-c">void lpush_back(ListNode *head, int val)
{
    ListNode *node = (ListNode*)malloc(sizeof(ListNode));
    ListNode *cursor = head;
    node-&gt;val = val;
    while(cursor-&gt;next) cursor = cursor-&gt;next;
    cursor-&gt;next = node;
}
</code></pre>
<h2 id="头部插入">头部插入</h2>
<pre><code class="language-c">void lpush_front(ListNode **head, int val)
{
    ListNode *node = (ListNode*)malloc(sizeof(ListNode));
    node-&gt;val = val;
    node-&gt;next =*head;
    *head = node;
}
</code></pre>
<h2 id="头部删除">头部删除</h2>
<h2 id="删除指定节点">删除指定节点</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】排序算法]]></title>
        <id>https://cactusii.github.io/post/pai-xu-suan-fa/</id>
        <link href="https://cactusii.github.io/post/pai-xu-suan-fa/">
        </link>
        <updated>2020-09-21T14:51:59.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600700055304.png" alt="" loading="lazy"></figure>
<h2 id="稳定排序">稳定排序</h2>
<h3 id="1直接插入排序-on2">1.直接插入排序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3>
<pre><code class="language-c++">void insSort(int *arr,int n)
{
    for(int i=0;i&lt;n;i++)
    {
        int tmp=arr[i];
        int j=i-1;
        while(j&gt;=0&amp;&amp;tmp&lt;arr[j])
        {
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=tmp;
    }
}
</code></pre>
<h3 id="2冒泡排序-on2">2.冒泡排序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3>
<pre><code class="language-c++">void bubSort(int *arr,int n)
{
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;n-i-1;j++)
            if(arr[j]&gt;arr[j+1])
                swap(arr[j],arr[j+1]);
}
</code></pre>
<h3 id="3二路归并排序">3.二路归并排序</h3>
<p>按照分治思想，将序列分为若干子序列，子序列有序，然后再将子序列合并为整体有序序列。</p>
<h3 id="4基数排序">4.基数排序</h3>
<p>桶子排序，按照基数对整个序列进行多次的排序。</p>
<h2 id="不稳定排序">不稳定排序</h2>
<h3 id="5选择排序">5.选择排序</h3>
<pre><code class="language-c++">void selSort(int *arr,int n)
{
    for(int i=0;i&lt;n;i++)
    {
        int MIN_index = i;
        for(int j=i;j&lt;n;j++)
            if(arr[MIN_index]&gt;arr[j]) MIN_index=j;
        swap(arr[MIN_index],arr[i]);
    }
}

</code></pre>
<h3 id="6快速排序">6.快速排序</h3>
<p>挖坑填坑的过程。</p>
<pre><code class="language-c++">void quiSort(int *arr,int l,int r)
{
    if(l&gt;=r) return;
    int base=arr[l];
    int i=l,j=r;
    while(i&lt;j)
    {
        while(arr[j]&gt;=base&amp;&amp;i&lt;j) j--;
        if(i&lt;j) arr[i++]=arr[j];
        while(arr[i]&lt;base&amp;&amp;i&lt;j) i++;
        if(i&lt;j) arr[j--]=arr[i];
    }
    arr[i]=base;
    quiSort(arr,l,i-1);
    quiSort(arr,i+1,r);
}

</code></pre>
<h3 id="7希尔排序">7.希尔排序</h3>
<p>希尔排序就是升级版的插入排序。</p>
<pre><code class="language-c++">void sheSort(int *arr,int n)
{
    int gap=n/2;
    while(gap&gt;=1)
    {
        for(int i=gap; i&lt;n; i++)
        {
            int j=i-gap;
            int tmp=arr[i];
            while(j&gt;=0&amp;&amp;tmp&lt;arr[j])
            {
                arr[j+gap]=arr[j];
                j-=gap;
            }
            arr[j+gap]=tmp;
        }
        gap/=2;
    }
}

</code></pre>
<h3 id="8堆排序">8.堆排序</h3>
<p>不断拿出堆顶结点然后调整大(小)顶堆的过程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【C++】没用的小知识]]></title>
        <id>https://cactusii.github.io/post/cmei-yong-de-xiao-zhi-shi/</id>
        <link href="https://cactusii.github.io/post/cmei-yong-de-xiao-zhi-shi/">
        </link>
        <updated>2020-09-21T14:42:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="c编译器">C++编译器</h2>
<p>C/C++常用的编译器是由GNU开发的GCC编译器。</p>
<h2 id="堆和栈的区别">堆和栈的区别</h2>
<h3 id="内存分配">内存分配</h3>
<p>一个由C/C++编译的程序占用的内存分为以下几个部分：</p>
<ol>
<li>栈区stack：由编译器自动分配释放，存放函数的参数值，局部变量等，其操作方式类似于数据结构中的栈。</li>
<li>堆区heap：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。与数据结构的堆是两回事。分配方式类似于链表。</li>
<li>全局区（静态区）static：全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。</li>
<li>文字常量区：常量字符串就是存放在这里。程序结束后由系统释放。</li>
<li>程序代码区：存放在函数体的二进制代码。</li>
</ol>
<pre><code class="language-c++">int   a   =   0;  // 全局初始化区
char   *p1;   //全局未初始化区    
main()    
{    
    int   b;   //栈    
    char   s[]   =   &quot;abc&quot;;   //栈    
    char   *p2;   //栈    
    char   *p3   =   &quot;123456&quot;;   //123456/0在常量区，p3在栈上。    
    static   int   c   =0；   //全局（静态）初始化区    
    p1 = (char   *)malloc(10);    
    p2 = (char   *)malloc(20);    
    p3 = new char[10];
    //p1p2p3分配得来得10和20字节的区域就在堆区。    
    strcpy(p1,   &quot;123456&quot;);   //123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方.
}  
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【C++】面向对象基基基基础]]></title>
        <id>https://cactusii.github.io/post/cji-ji-ji-ji-chu-mian-xiang-dui-xiang/</id>
        <link href="https://cactusii.github.io/post/cji-ji-ji-ji-chu-mian-xiang-dui-xiang/">
        </link>
        <updated>2020-09-21T09:27:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1构造函数析构函数类和对象">1.构造函数&amp;析构函数（类和对象）</h2>
<h2 id="2基类派生类继承">2.基类&amp;派生类（继承）</h2>
<h2 id="3函数重载虚函数多态">3.函数重载&amp;虚函数（多态）</h2>
<h2 id="4抽象">4.抽象</h2>
<h2 id="5接口抽象类">5.接口（抽象类）</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浮点数的存储方法以及python的Decimal]]></title>
        <id>https://cactusii.github.io/post/fu-dian-shu-de-cun-chu-fang-fa-yi-ji-python-de-decimal/</id>
        <link href="https://cactusii.github.io/post/fu-dian-shu-de-cun-chu-fang-fa-yi-ji-python-de-decimal/">
        </link>
        <updated>2020-09-19T02:06:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="浮点数的存储方式">浮点数的存储方式</h2>
<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600483237666.jpg" alt="" loading="lazy"></figure>
<h2 id="decimaldecimal">decimal.Decimal</h2>
<p>python中的decimal.Decimal类型可以非常精确地存储在计算机中，其优于float类型。<br>
用法：</p>
<pre><code class="language-python">from decimal import Decimal

# 字符串/浮点数转换为Decimal
Decimal('1.11')
# &gt;&gt;Decimal('1.11')
Decimal(1.11)
# &gt;&gt;Decimal('1.1100000000000000976996261670137755572795867919921875')

# 四舍五入
Decimal('50.5679').quantize(Decimal('0.00'))
# &gt;&gt;Decimal('50.57')

# Decimal 结果转化为string
str(Decimal('3.40').quantize(Decimal('0.0')))
# &gt;&gt;'3.4'

</code></pre>
<p>将浮点数以二进制输出：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
	float fnum = 1;
	int i;
	int * p = (int *)&amp;fnum;//定义一个指向fnum的指针
        int x=0;//设置flag变量
	while (fnum != 0)//以0作为输入结束标志
	{
		printf(&quot;input a num: &quot;);
		x=scanf(&quot;%f&quot;, &amp;fnum);
                if(!x)//判断是否输入成功
                {
                       printf(&quot;wrong\n&quot;);
                       fflush(stdin);//清空输入流，不然会死循环
                       continue;
                }
		for (i = 31; i &gt;= 0; i--)
		{
                      /*将1左移i位，通过与运算判断第i位是否为1*/
                      printf(&quot;%d&quot;, (*p &amp; (1 &lt;&lt; i) ? 1: 0));
                      /*控制空格输入*/
                      if(i==31||i==23)
                           printf(&quot;  &quot;);
                      if(i==27||i==19||i==15||i==11||i==7||i==3)
                           printf(&quot; &quot;);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>