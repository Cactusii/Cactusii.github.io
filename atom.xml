<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cactusii.github.io/</id>
    <title>Cactuii&apos;s Blog</title>
    <updated>2020-09-28T13:19:50.427Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cactusii.github.io/"/>
    <link rel="self" href="https://cactusii.github.io/atom.xml"/>
    <subtitle>我咸甚，此鱼何能及我也！</subtitle>
    <logo>https://cactusii.github.io/images/avatar.png</logo>
    <icon>https://cactusii.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Cactuii&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[【算法】数学]]></title>
        <id>https://cactusii.github.io/post/suan-fa-shu-xue/</id>
        <link href="https://cactusii.github.io/post/suan-fa-shu-xue/">
        </link>
        <updated>2020-09-28T05:21:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="分解质因数">分解质因数</h2>
<pre><code class="language-c++">void primeFactor(int n)
{
    for(int i=2;i&lt;sqrt(n);i++)
    {
        while(n%i==0) //输出所有可以约去的数
        {
            cout&lt;&lt;i&lt;&lt;&quot; &quot;;
            n/=i;
        }
    }
}
</code></pre>
<p>一个自然数的约数个数是它各质因数的次数分别加1相乘的积。<br>
例：18的因数有：1，2，3，6，9，18。而其质因数有18=2×2×3。<br>
<img src="https://cactusii.github.io//post-images/1601271024765.jpg" alt="" loading="lazy"><br>
即(1+1) * (2+1)=6个。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java技能树]]></title>
        <id>https://cactusii.github.io/post/java-ji-neng-shu/</id>
        <link href="https://cactusii.github.io/post/java-ji-neng-shu/">
        </link>
        <updated>2020-09-27T10:15:56.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1601201773805.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】二叉树]]></title>
        <id>https://cactusii.github.io/post/shu-ju-jie-gou-er-cha-shu/</id>
        <link href="https://cactusii.github.io/post/shu-ju-jie-gou-er-cha-shu/">
        </link>
        <updated>2020-09-23T06:30:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="二叉树的存储">二叉树的存储</h2>
<h3 id="1-顺序存储结构">1. 顺序存储结构</h3>
<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600843894170.jpg" alt="" loading="lazy"></figure>
<h3 id="2链式存储">2.链式存储</h3>
<figure data-type="image" tabindex="2"><img src="https://cactusii.github.io//post-images/1600843945025.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-c++">typedef struct node
{
    int data;
    struct node *lchild, *rchild;
}Bitree;
</code></pre>
<h2 id="二叉树的访问">二叉树的访问</h2>
<h3 id="先序访问">先序访问</h3>
<pre><code class="language-c++">void preOrderTraveral(Bitree *node) //递归
{
    if(node == NULL)
    {
        return;
    }
    printf(&quot;%d &quot;,node-&gt;data);
    preOrderTraveral(node-&gt;lchild);
    preOrderTraveral(node-&gt;rchild);
}


void _preOrderTraveral(Bitree *node) //非递归
{
    stack&lt;Bitree*&gt; s;
    Bitree *tmp_node = node;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL)
        {
            printf(&quot;%d &quot;,tmp_node-&gt;data);
            s.push(tmp_node);
            tmp_node = tmp_node-&gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            tmp_node = tmp_node-&gt;rchild;
        }
    }
}
</code></pre>
<h3 id="中序访问">中序访问</h3>
<pre><code class="language-c++">void inOrderTraveral(Bitree *node)
{
    if(node == NULL)
    {
        return;
    }
    inOrderTraveral(node-&gt;lchild);
    printf(&quot;%d &quot;,node-&gt;data);
    inOrderTraveral(node-&gt;rchild);
}


void _inOrderTraveral(Bitree *node)
{
    stack&lt;Bitree*&gt; s;
    Bitree *tmp_node = node;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL)
        {
            s.push(tmp_node);
            tmp_node = tmp_node-&gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            printf(&quot;%d &quot;,tmp_node-&gt;data);
            tmp_node = tmp_node-&gt;rchild;
        }
    }
}
</code></pre>
<h3 id="后序访问">后序访问</h3>
<pre><code class="language-c++">void postOrderTraveral(Bitree *node)
{
    if(node == NULL)
    {
        return;
    }
    postOrderTraveral(node-&gt;lchild);
    postOrderTraveral(node-&gt;rchild);
    printf(&quot;%d &quot;,node-&gt;data);
}


void _postOrderTraveral(Bitree *node)
{
    stack&lt;Bitree*&gt; s;
    Bitree *tmp_node = node, *lastVisit = NULL;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL) //左节点入栈
        {
            s.push(tmp_node);
            tmp_node = tmp_node-&gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            if(tmp_node-&gt;rchild==NULL || tmp_node-&gt;rchild==lastVisit) //此节点右孩子为空或者已访问过，那么访问此节点
            {
                printf(&quot;%d &quot;,tmp_node-&gt;data);
                lastVisit = tmp_node;
                tmp_node = NULL;
            }
            else
            {
                s.push(tmp_node);
                tmp_node = tmp_node-&gt;rchild;
            }
        }
    }
}
</code></pre>
<p>层次遍历<br>
二叉树的层次遍历基于广度优先搜索，<font color='red'>在访问第n层时，一定会访问完第n-1层</font>。</p>
<pre><code class="language-c++">void levelOrder(Bitree *root)
{
    if(!root) return;
    queue&lt;Bitree *&gt; q;
    q.push(root);
    while(!q.empty())
    {
        Bitree tmp = q.front();
        q.pop();
        printf(&quot;%d&quot;,tmp-&gt;data);
        if(tmp-&gt;lchild) q.push(tmp.lchild);
        if(tmp-&gt;rchild) q.push(tmp.rchild);
    }
}
</code></pre>
<h2 id="0二叉搜索树">0二叉搜索树</h2>
<p>左子树的所有结点值均小于根结点的值；右子树的所有结点值均大于根结点的值；左子树也是二叉搜索树。</p>
<h3 id="二叉搜索树的构建">二叉搜索树的构建</h3>
<pre><code class="language-c++">typedef struct TreeNode
{
    int val;
    struct TreeNode *lchild, *rchild;
}TreeNode;

void Create(TreeNode *root, int tmp)
{
    if(!root)
    {
        root = (TreeNode *)malloc(sizeof(TreeNode));
        root-&gt;val = tmp;
        return;
    }
    if(root-&gt;val &lt; tmp)
        Create(root-&gt;lchild,tmp);
    else
        Create(root-&gt;rchild,tmp);
}
</code></pre>
<h3 id="二叉搜索树结点的删除">二叉搜索树结点的删除</h3>
<ol>
<li>如果删除的结点只有左孩子或者只有有孩子，那么直接删除，然后把其孩子加到父节点上。<br>
<img src="https://cactusii.github.io//post-images/1600996986954.jpg" alt="" loading="lazy"></li>
<li>如果删除的结点有左孩子和有孩子，那么删除此节点后，需要将其左子树的最大结点或者右子树的最小节点替换上来。<img src="https://cactusii.github.io//post-images/1600997012992.jpg" alt="" loading="lazy"></li>
</ol>
<h3 id="找到二叉搜索树两个结点的最近的双亲结点">找到二叉搜索树两个结点的最近的双亲结点</h3>
<p>利用二叉搜索树的特点，遍历整个二叉树，如果两个节点都小于当前遍历结点，那么递归到其左子树；如果两个结点都大于当前遍历结点，那么递归到其右子树上，如果一个大于一个小于当前遍历结点，那么此结点即为其最近的双亲结点。</p>
<pre><code class="language-c++">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)
        return lowestCommonAncestor(root-&gt;left,p,q);
    else if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)
        return lowestCommonAncestor(root-&gt;right,p,q);
    return root;
}
</code></pre>
<p>二叉搜索树的中序遍历是递增顺序</p>
<h2 id="由中序和后序还原二叉树">由中序和后序还原二叉树</h2>
<ol>
<li>后序中右起第一位3肯定是根结点，我们可以据此找到中序中根结点的位置rootin；</li>
<li>中序中根结点左边就是左子树结点，右边就是右子树结点，即[左子树结点，根结点，右子树结点]，我们就可以得出左子树结点个数为int left_count = tmp - inleft;；</li>
<li>后序中结点分布应该是：[左子树结点，右子树结点，根结点]；</li>
<li>根据前一步确定的左子树个数，可以确定后序中左子树结点和右子树结点的范围；</li>
<li>如果我们要前序遍历生成二叉树的话，下一层递归应该是：</li>
</ol>
<ul>
<li>左子树：root-&gt;left = pre_order(中序左子树范围，后序左子树范围，中序序列，后序序列);；</li>
<li>右子树：root-&gt;right = pre_order(中序右子树范围，后序右子树范围，中序序列，后序序列);。</li>
</ul>
<ol start="6">
<li>每一层递归都要返回当前根结点root；</li>
</ol>
<pre><code class="language-c++">TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
    TreeNode *root = pre_order(0,inorder.size()-1, 0,postorder.size()-1, inorder, postorder);
    return root;
}

TreeNode *pre_order(int inleft, int inright, int postleft, int postright, vector&lt;int&gt; &amp;inorder, vector&lt;int&gt;&amp; postorder)
{
    if(inleft&gt;inright) return NULL;
    TreeNode *root = new TreeNode(postorder[postright]);
    int tmp = inleft;
    while(inorder[tmp]!=postorder[postright]) tmp++;
    int left_count = tmp - inleft; //左子树的结点个数
    root-&gt;left = pre_order(inleft,tmp-1,postleft,postleft+left_count-1,inorder,postorder);
    root-&gt;right = pre_order(tmp+1,inright,postleft+left_count,postright-1,inorder,postorder);
    return root;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】并查集]]></title>
        <id>https://cactusii.github.io/post/shu-ju-jie-gou-bing-cha-ji/</id>
        <link href="https://cactusii.github.io/post/shu-ju-jie-gou-bing-cha-ji/">
        </link>
        <updated>2020-09-22T02:23:07.000Z</updated>
        <content type="html"><![CDATA[<p>并查集主要用于处理一些不相交集合的问题。</p>
<p>每个集合包含一个或多个元素，并且有一个代表元素。对于给定一个元素，可以快速找到其所属集合的代表元素，这样判断两个元素是否属于同一集合，只需要判断二者所属集合的代表元素是否一致即可。</p>
<p>如果要合并两个集合，只需要将其中一个集合的代表元素设为另一个集合的代表元素即可。</p>
<hr>
<p><strong>涉及到的主要操作有两个</strong></p>
<ol>
<li>合并：把两个元素所属集合合并（前提是两个集合不相交）</li>
</ol>
<pre><code class="language-c">void join(int a, int b)
{
    int tmpa,tmpb;
    tmpa = find_root(a);
    tmpb = find_root(b);
    if(tmpa!=tmpb)
        root[tmpa] = tmpb;
}
</code></pre>
<ol start="2">
<li>查找根（代表元素）：找到某一个元素的所属集合的根。</li>
</ol>
<pre><code class="language-c">int find_root(int x)
{
    while(x!=root[x])
        x = root[x];
    return x;
}

//root[x]=y表示x的根是y，初始化时，每个元素的根都是自己
</code></pre>
<p><strong>路径压缩</strong><br>
查找根最坏的一种情况是一条常常的链，这时候查找的效率会大大降低，此时可以使用路径压缩，即将每个元素直接指向根节点 ，如下图。<br>
<img src="https://cactusii.github.io//post-images/1600744618773.jpg" alt="" loading="lazy"></p>
<p>我们可以在查找的过程中把每个元素的父节点直接设成根节点。</p>
<pre><code class="language-c">int find_root(int x)
{
    int root_of_x = x; //根节点
   
    while(root_of_x != root[root_of_x])
        root_of_x = root[root_of_x];

    while(x != root[x]) //将每个子节点的父节点都换成根节点
    {
        int tmp = x;
        x = root[x];
        root[tmp] = root_of_x;
    }
    return root_of_x;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】链表的存储]]></title>
        <id>https://cactusii.github.io/post/shu-ju-jie-gou-lian-biao-de-cun-chu/</id>
        <link href="https://cactusii.github.io/post/shu-ju-jie-gou-lian-biao-de-cun-chu/">
        </link>
        <updated>2020-09-22T00:33:29.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600735871236.png" alt="" loading="lazy"></figure>
<h2 id="定义链表结构体">定义链表结构体</h2>
<pre><code class="language-c">typedef struct ListNode
{
    int val;
    struct ListNode *next;
}ListNode;
</code></pre>
<h2 id="遍历链表">遍历链表</h2>
<pre><code class="language-c">void print(ListNode *head)
{
    for(ListNode *cursor = head; cursor; cursor = cursor-&gt;next)
    {
        printf(&quot;%d-&gt;&quot;,cursor-&gt;val);
    }
}
</code></pre>
<h2 id="尾部插入">尾部插入</h2>
<pre><code class="language-c">void lpush_back(ListNode *head, int val)
{
    ListNode *node = (ListNode*)malloc(sizeof(ListNode));
    ListNode *cursor = head;
    node-&gt;val = val;
    while(cursor-&gt;next) cursor = cursor-&gt;next;
    cursor-&gt;next = node;
}
</code></pre>
<h2 id="头部插入">头部插入</h2>
<pre><code class="language-c">void lpush_front(ListNode **head, int val)
{
    ListNode *node = (ListNode*)malloc(sizeof(ListNode));
    node-&gt;val = val;
    node-&gt;next =*head;
    *head = node;
}
</code></pre>
<h2 id="头部删除">头部删除</h2>
<h2 id="删除指定节点">删除指定节点</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】排序算法]]></title>
        <id>https://cactusii.github.io/post/pai-xu-suan-fa/</id>
        <link href="https://cactusii.github.io/post/pai-xu-suan-fa/">
        </link>
        <updated>2020-09-21T14:51:59.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600700055304.png" alt="" loading="lazy"></figure>
<h2 id="稳定排序">稳定排序</h2>
<h3 id="1直接插入排序-on2">1.直接插入排序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3>
<pre><code class="language-c++">void insSort(int *arr,int n)
{
    for(int i=0;i&lt;n;i++)
    {
        int tmp=arr[i];
        int j=i-1;
        while(j&gt;=0&amp;&amp;tmp&lt;arr[j])
        {
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=tmp;
    }
}
</code></pre>
<h3 id="2冒泡排序-on2">2.冒泡排序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3>
<pre><code class="language-c++">void bubSort(int *arr,int n)
{
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;n-i-1;j++)
            if(arr[j]&gt;arr[j+1])
                swap(arr[j],arr[j+1]);
}
</code></pre>
<h3 id="3二路归并排序">3.二路归并排序</h3>
<p>按照分治思想，将序列分为若干子序列，子序列有序，然后再将子序列合并为整体有序序列。</p>
<h3 id="4基数排序">4.基数排序</h3>
<p>桶子排序，按照基数对整个序列进行多次的排序。</p>
<h2 id="不稳定排序">不稳定排序</h2>
<h3 id="5选择排序">5.选择排序</h3>
<pre><code class="language-c++">void selSort(int *arr,int n)
{
    for(int i=0;i&lt;n;i++)
    {
        int MIN_index = i;
        for(int j=i;j&lt;n;j++)
            if(arr[MIN_index]&gt;arr[j]) MIN_index=j;
        swap(arr[MIN_index],arr[i]);
    }
}

</code></pre>
<h3 id="6快速排序">6.快速排序</h3>
<p>挖坑填坑的过程。</p>
<pre><code class="language-c++">void quiSort(int *arr,int l,int r)
{
    if(l&gt;=r) return;
    int base=arr[l];
    int i=l,j=r;
    while(i&lt;j)
    {
        while(arr[j]&gt;=base&amp;&amp;i&lt;j) j--;
        if(i&lt;j) arr[i++]=arr[j];
        while(arr[i]&lt;base&amp;&amp;i&lt;j) i++;
        if(i&lt;j) arr[j--]=arr[i];
    }
    arr[i]=base;
    quiSort(arr,l,i-1);
    quiSort(arr,i+1,r);
}

</code></pre>
<h3 id="7希尔排序">7.希尔排序</h3>
<p>希尔排序就是升级版的插入排序。</p>
<pre><code class="language-c++">void sheSort(int *arr,int n)
{
    int gap=n/2;
    while(gap&gt;=1)
    {
        for(int i=gap; i&lt;n; i++)
        {
            int j=i-gap;
            int tmp=arr[i];
            while(j&gt;=0&amp;&amp;tmp&lt;arr[j])
            {
                arr[j+gap]=arr[j];
                j-=gap;
            }
            arr[j+gap]=tmp;
        }
        gap/=2;
    }
}

</code></pre>
<h3 id="8堆排序">8.堆排序</h3>
<p>不断拿出堆顶结点然后调整大(小)顶堆的过程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【C++】没用的小知识]]></title>
        <id>https://cactusii.github.io/post/cmei-yong-de-xiao-zhi-shi/</id>
        <link href="https://cactusii.github.io/post/cmei-yong-de-xiao-zhi-shi/">
        </link>
        <updated>2020-09-21T14:42:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="c编译器">C++编译器</h2>
<p>C/C++常用的编译器是由GNU开发的GCC编译器。</p>
<h2 id="堆和栈的区别">堆和栈的区别</h2>
<h3 id="内存分配">内存分配</h3>
<p>一个由C/C++编译的程序占用的内存分为以下几个部分：</p>
<ol>
<li>栈区stack：由编译器自动分配释放，存放函数的参数值，局部变量等，其操作方式类似于数据结构中的栈。</li>
<li>堆区heap：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。与数据结构的堆是两回事。分配方式类似于链表。</li>
<li>全局区（静态区）static：全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。</li>
<li>文字常量区：常量字符串就是存放在这里。程序结束后由系统释放。</li>
<li>程序代码区：存放在函数体的二进制代码。</li>
</ol>
<pre><code class="language-c++">int   a   =   0;  // 全局初始化区
char   *p1;   //全局未初始化区    
main()    
{    
    int   b;   //栈    
    char   s[]   =   &quot;abc&quot;;   //栈    
    char   *p2;   //栈    
    char   *p3   =   &quot;123456&quot;;   //123456/0在常量区，p3在栈上。    
    static   int   c   =0；   //全局（静态）初始化区    
    p1 = (char   *)malloc(10);    
    p2 = (char   *)malloc(20);    
    p3 = new char[10];
    //p1p2p3分配得来得10和20字节的区域就在堆区。    
    strcpy(p1,   &quot;123456&quot;);   //123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方.
}  
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【C++】面向对象基基基基础]]></title>
        <id>https://cactusii.github.io/post/cji-ji-ji-ji-chu-mian-xiang-dui-xiang/</id>
        <link href="https://cactusii.github.io/post/cji-ji-ji-ji-chu-mian-xiang-dui-xiang/">
        </link>
        <updated>2020-09-21T09:27:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1构造函数析构函数类和对象">1.构造函数&amp;析构函数（类和对象）</h2>
<h2 id="2基类派生类继承">2.基类&amp;派生类（继承）</h2>
<h2 id="3函数重载虚函数多态">3.函数重载&amp;虚函数（多态）</h2>
<h2 id="4抽象">4.抽象</h2>
<h2 id="5接口抽象类">5.接口（抽象类）</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浮点数的存储方法以及python的Decimal]]></title>
        <id>https://cactusii.github.io/post/fu-dian-shu-de-cun-chu-fang-fa-yi-ji-python-de-decimal/</id>
        <link href="https://cactusii.github.io/post/fu-dian-shu-de-cun-chu-fang-fa-yi-ji-python-de-decimal/">
        </link>
        <updated>2020-09-19T02:06:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="浮点数的存储方式">浮点数的存储方式</h2>
<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600483237666.jpg" alt="" loading="lazy"></figure>
<h2 id="decimaldecimal">decimal.Decimal</h2>
<p>python中的decimal.Decimal类型可以非常精确地存储在计算机中，其优于float类型。<br>
用法：</p>
<pre><code class="language-python">from decimal import Decimal

# 字符串/浮点数转换为Decimal
Decimal('1.11')
# &gt;&gt;Decimal('1.11')
Decimal(1.11)
# &gt;&gt;Decimal('1.1100000000000000976996261670137755572795867919921875')

# 四舍五入
Decimal('50.5679').quantize(Decimal('0.00'))
# &gt;&gt;Decimal('50.57')

# Decimal 结果转化为string
str(Decimal('3.40').quantize(Decimal('0.0')))
# &gt;&gt;'3.4'

</code></pre>
<p>将浮点数以二进制输出：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
	float fnum = 1;
	int i;
	int * p = (int *)&amp;fnum;//定义一个指向fnum的指针
        int x=0;//设置flag变量
	while (fnum != 0)//以0作为输入结束标志
	{
		printf(&quot;input a num: &quot;);
		x=scanf(&quot;%f&quot;, &amp;fnum);
                if(!x)//判断是否输入成功
                {
                       printf(&quot;wrong\n&quot;);
                       fflush(stdin);//清空输入流，不然会死循环
                       continue;
                }
		for (i = 31; i &gt;= 0; i--)
		{
                      /*将1左移i位，通过与运算判断第i位是否为1*/
                      printf(&quot;%d&quot;, (*p &amp; (1 &lt;&lt; i) ? 1: 0));
                      /*控制空格输入*/
                      if(i==31||i==23)
                           printf(&quot;  &quot;);
                      if(i==27||i==19||i==15||i==11||i==7||i==3)
                           printf(&quot; &quot;);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[科研小白进阶路]]></title>
        <id>https://cactusii.github.io/post/ke-yan-xiao-bai/</id>
        <link href="https://cactusii.github.io/post/ke-yan-xiao-bai/">
        </link>
        <updated>2020-09-17T04:55:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1什么是sci">1.什么是SCI</h2>
<p>SCI(Science Citation Index)不是特指某一个学术期刊，而实一个索引，给已经发表的文章建立一个索引，方便查找以及引用的跟踪，可以理解成一座图书馆的图书索引，通过这些索引可以找到想要的论文，阅读和引用，不是所有的科研论文都可以纳入SCI的索引的范围内，只有SCI组织觉得某些期刊可以引用的，才会被纳入进来，其他的索引，例如EI，ESI</p>
<h2 id="2期刊论文">2.期刊论文</h2>
<p>通常期刊论文会比较完整、系统，好的期刊会被SCI收纳引用，期刊论文相对于会议论文发表更难一些，大部分高校和用人单位看的是期刊论文。不需要去开会，需要多轮的审稿。</p>
<p>期刊的种类：</p>
<ul>
<li>提出新颖的方法，但没有完整的解决方案</li>
<li>Survey 归纳总结该领域的工作</li>
</ul>
<h2 id="3会议论文">3.会议论文</h2>
<p>会议论文是需要你去参加会议，宣讲你的研究成果<br>
查找会议的相关信息：www.edas.info<br>
一轮审稿，通过与不通过都是一轮</p>
<p>在写之前应该先看看论文的Author Guidelines</p>
<h2 id="4影响因子">4.影响因子</h2>
<p>一般通过这个来看这个期刊的影响力，由论文引用量等等的影响。</p>
<h2 id="5sci划区">5.SCI划区</h2>
<p>SCI期刊与国内期刊有所不同，国内期刊有省级、国家级、核心级的划分，SCI期刊也有级别的划分，不同的是SCI对期刊进行了分区，分区标准有两类：</p>
<ul>
<li>中科院的分区
<ul>
<li>共分为四区，影响因子5%为1区、6%<sub>20%为2区、20%</sub>50%为3区、之后为4区。</li>
</ul>
</li>
<li>jcr分区（汤森路透分区）
<ul>
<li>共分为1、2、3、4区，1区影响因子为前25%、2区25%<sub>50%、3区50%</sub>75%、之后为4区。</li>
</ul>
</li>
</ul>
<p>CNKI收录的大部分是国内的硕博论文和国内的期刊</p>
<h2 id="干货">干货：</h2>
<ol>
<li>
<p><strong>读</strong></p>
<ul>
<li><strong>怎么搜？</strong>
<ul>
<li>首先得先学会查业内相关的文献，工具有Google Scholar，Web of Science，Scopus，然后输入特定的方向，例如在Google Scholar上搜索网络安全，然后左侧有一个筛选，选择2020年最新的<img src="https://cactusii.github.io//post-images/1600342772850.png" alt="" loading="lazy">    <font color='red'>然后每个方向每年有多少篇论文整理下，对比下，这样做是为了确定两个东西，一个是你得确定做这个的community不太大，太大了论文太多你入门很困难，第二是在此基础上确保你想做的这个是个朝阳产业，就是一年论文比一年多的那种，夕阳产业就别做了。而且你在一个小的方向上做一段时间后你就会发现相关的其它小方向就触类旁通了。</font></li>
<li>阅读几个方向的论文后，定下自己的方向，然后就海量的读论文。先读行业内顶刊的综述类论文，对框架进行了解，然后再选择行业内最新的论文读，看看最新的创新点都在什么地方，这种地方还有没有漏洞或者有人没做过的，整理出来，最后筛选下出来5-10个ideas，就可以正式进实验室啦。</li>
</ul>
</li>
<li><strong>怎么管？</strong>
<ul>
<li>文献管理</li>
</ul>
</li>
<li><strong>怎么读？</strong></li>
</ul>
</li>
<li>
<p><strong>写</strong></p>
<ul>
<li>英文写作能力</li>
<li>学术论文写作方法</li>
</ul>
</li>
</ol>
<p>综述选题背景<br>
总结前人成果<br>
提出实验方案<br>
分析我的优秀<br>
致谢</p>
<ol start="3">
<li><strong>投稿</strong>
<ul>
<li>怎么找合适的期刊\会议</li>
<li>投了之后的一系列事情</li>
</ul>
</li>
</ol>
<h2 id="项目">项目</h2>
<ul>
<li>横向：企业/机构合作的项目，适合专硕做</li>
<li>纵向：国家部委、省市的研究课题(国家自然科学基金)，有论文指标的要求，学硕专硕都适合。</li>
</ul>
<h2 id="三年规划">三年规划</h2>
<p>研一：</p>
<ul>
<li>上课</li>
<li>读论文</li>
</ul>
<p>研二：</p>
<ul>
<li>写论文发论文</li>
<li>做项目</li>
</ul>
<p><strong>以上内容部分参考自：</strong></p>
<blockquote>
<p>作者：Leslie Young<br>
链接：https://www.zhihu.com/question/385466539/answer/1133113105<br>
来源：知乎<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
    </entry>
</feed>