<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cactusii.github.io/</id>
    <title>Cactuii&apos;s Blog</title>
    <updated>2020-09-23T08:13:24.714Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cactusii.github.io/"/>
    <link rel="self" href="https://cactusii.github.io/atom.xml"/>
    <subtitle>我咸甚，此鱼何能及我也！</subtitle>
    <logo>https://cactusii.github.io/images/avatar.png</logo>
    <icon>https://cactusii.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Cactuii&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[【数据结构】二叉树]]></title>
        <id>https://cactusii.github.io/post/shu-ju-jie-gou-er-cha-shu/</id>
        <link href="https://cactusii.github.io/post/shu-ju-jie-gou-er-cha-shu/">
        </link>
        <updated>2020-09-23T06:30:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="二叉树的存储">二叉树的存储</h2>
<h3 id="1-顺序存储结构">1. 顺序存储结构</h3>
<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600843894170.jpg" alt="" loading="lazy"></figure>
<h3 id="2链式存储">2.链式存储</h3>
<figure data-type="image" tabindex="2"><img src="https://cactusii.github.io//post-images/1600843945025.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-c++">typedef struct node
{
    int data;
    struct node *lchild, *rchild;
}Bitree;
</code></pre>
<h2 id="二叉树的访问">二叉树的访问</h2>
<h3 id="先序访问">先序访问</h3>
<pre><code class="language-c++">void preOrderTraveral(Bitree *node) //递归
{
    if(node == NULL)
    {
        return;
    }
    printf(&quot;%d &quot;,node-&gt;data);
    preOrderTraveral(node-&gt;lchild);
    preOrderTraveral(node-&gt;rchild);
}


void _preOrderTraveral(Bitree *node) //非递归
{
    stack&lt;Bitree*&gt; s;
    Bitree *tmp_node = node;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL)
        {
            printf(&quot;%d &quot;,tmp_node-&gt;data);
            s.push(tmp_node);
            tmp_node = tmp_node-&gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            tmp_node = tmp_node-&gt;rchild;
        }
    }
}
</code></pre>
<h3 id="中序访问">中序访问</h3>
<pre><code class="language-c++">void inOrderTraveral(Bitree *node)
{
    if(node == NULL)
    {
        return;
    }
    inOrderTraveral(node-&gt;lchild);
    printf(&quot;%d &quot;,node-&gt;data);
    inOrderTraveral(node-&gt;rchild);
}


void _inOrderTraveral(Bitree *node)
{
    stack&lt;Bitree*&gt; s;
    Bitree *tmp_node = node;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL)
        {
            s.push(tmp_node);
            tmp_node = tmp_node-&gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            printf(&quot;%d &quot;,tmp_node-&gt;data);
            tmp_node = tmp_node-&gt;rchild;
        }
    }
}
</code></pre>
<h3 id="后序访问">后序访问</h3>
<pre><code class="language-c++">void postOrderTraveral(Bitree *node)
{
    if(node == NULL)
    {
        return;
    }
    postOrderTraveral(node-&gt;lchild);
    postOrderTraveral(node-&gt;rchild);
    printf(&quot;%d &quot;,node-&gt;data);
}


void _postOrderTraveral(Bitree *node)
{
    stack&lt;Bitree*&gt; s;
    Bitree *tmp_node = node, *lastVisit = NULL;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL) //左节点入栈
        {
            s.push(tmp_node);
            tmp_node = tmp_node-&gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            if(tmp_node-&gt;rchild==NULL || tmp_node-&gt;rchild==lastVisit) //此节点右孩子为空或者已访问过，那么访问此节点
            {
                printf(&quot;%d &quot;,tmp_node-&gt;data);
                lastVisit = tmp_node;
                tmp_node = NULL;
            }
            else
            {
                s.push(tmp_node);
                tmp_node = tmp_node-&gt;rchild;
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】并查集]]></title>
        <id>https://cactusii.github.io/post/shu-ju-jie-gou-bing-cha-ji/</id>
        <link href="https://cactusii.github.io/post/shu-ju-jie-gou-bing-cha-ji/">
        </link>
        <updated>2020-09-22T02:23:07.000Z</updated>
        <content type="html"><![CDATA[<p>并查集主要用于处理一些不相交集合的问题。</p>
<p>每个集合包含一个或多个元素，并且有一个代表元素。对于给定一个元素，可以快速找到其所属集合的代表元素，这样判断两个元素是否属于同一集合，只需要判断二者所属集合的代表元素是否一致即可。</p>
<p>如果要合并两个集合，只需要将其中一个集合的代表元素设为另一个集合的代表元素即可。</p>
<hr>
<p><strong>涉及到的主要操作有两个</strong></p>
<ol>
<li>合并：把两个元素所属集合合并（前提是两个集合不相交）</li>
</ol>
<pre><code class="language-c">void join(int a, int b)
{
    int tmpa,tmpb;
    tmpa = find_root(a);
    tmpb = find_root(b);
    if(tmpa!=tmpb)
        root[tmpa] = tmpb;
}
</code></pre>
<ol start="2">
<li>查找根（代表元素）：找到某一个元素的所属集合的根。</li>
</ol>
<pre><code class="language-c">int find_root(int x)
{
    while(x!=root[x])
        x = root[x];
    return x;
}

//root[x]=y表示x的根是y，初始化时，每个元素的根都是自己
</code></pre>
<p><strong>路径压缩</strong><br>
查找根最坏的一种情况是一条常常的链，这时候查找的效率会大大降低，此时可以使用路径压缩，即将每个元素直接指向根节点 ，如下图。<br>
<img src="https://cactusii.github.io//post-images/1600744618773.jpg" alt="" loading="lazy"></p>
<p>我们可以在查找的过程中把每个元素的父节点直接设成根节点。</p>
<pre><code class="language-c">int find_root(int x)
{
    int root_of_x = x; //根节点
   
    while(root_of_x != root[root_of_x])
        root_of_x = root[root_of_x];

    while(x != root[x]) //将每个子节点的父节点都换成根节点
    {
        int tmp = x;
        x = root[x];
        root[tmp] = root_of_x;
    }
    return root_of_x;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】链表的存储]]></title>
        <id>https://cactusii.github.io/post/shu-ju-jie-gou-lian-biao-de-cun-chu/</id>
        <link href="https://cactusii.github.io/post/shu-ju-jie-gou-lian-biao-de-cun-chu/">
        </link>
        <updated>2020-09-22T00:33:29.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600735871236.png" alt="" loading="lazy"></figure>
<h2 id="定义链表结构体">定义链表结构体</h2>
<pre><code class="language-c">typedef struct ListNode
{
    int val;
    struct ListNode *next;
}ListNode;
</code></pre>
<h2 id="遍历链表">遍历链表</h2>
<pre><code class="language-c">void print(ListNode *head)
{
    for(ListNode *cursor = head; cursor; cursor = cursor-&gt;next)
    {
        printf(&quot;%d-&gt;&quot;,cursor-&gt;val);
    }
}
</code></pre>
<h2 id="尾部插入">尾部插入</h2>
<pre><code class="language-c">void lpush_back(ListNode *head, int val)
{
    ListNode *node = (ListNode*)malloc(sizeof(ListNode));
    ListNode *cursor = head;
    node-&gt;val = val;
    while(cursor-&gt;next) cursor = cursor-&gt;next;
    cursor-&gt;next = node;
}
</code></pre>
<h2 id="头部插入">头部插入</h2>
<pre><code class="language-c">void lpush_front(ListNode **head, int val)
{
    ListNode *node = (ListNode*)malloc(sizeof(ListNode));
    node-&gt;val = val;
    node-&gt;next =*head;
    *head = node;
}
</code></pre>
<h2 id="头部删除">头部删除</h2>
<h2 id="删除指定节点">删除指定节点</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】排序算法]]></title>
        <id>https://cactusii.github.io/post/pai-xu-suan-fa/</id>
        <link href="https://cactusii.github.io/post/pai-xu-suan-fa/">
        </link>
        <updated>2020-09-21T14:51:59.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600700055304.png" alt="" loading="lazy"></figure>
<h2 id="稳定排序">稳定排序</h2>
<h3 id="1直接插入排序-on2">1.直接插入排序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3>
<pre><code class="language-c++">void insSort(int *arr,int n)
{
    for(int i=0;i&lt;n;i++)
    {
        int tmp=arr[i];
        int j=i-1;
        while(j&gt;=0&amp;&amp;tmp&lt;arr[j])
        {
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=tmp;
    }
}
</code></pre>
<h3 id="2冒泡排序-on2">2.冒泡排序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3>
<pre><code class="language-c++">void bubSort(int *arr,int n)
{
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;n-i-1;j++)
            if(arr[j]&gt;arr[j+1])
                swap(arr[j],arr[j+1]);
}
</code></pre>
<h3 id="3二路归并排序">3.二路归并排序</h3>
<p>按照分治思想，将序列分为若干子序列，子序列有序，然后再将子序列合并为整体有序序列。</p>
<h3 id="4基数排序">4.基数排序</h3>
<p>桶子排序，按照基数对整个序列进行多次的排序。</p>
<h2 id="不稳定排序">不稳定排序</h2>
<h3 id="5选择排序">5.选择排序</h3>
<pre><code class="language-c++">void selSort(int *arr,int n)
{
    for(int i=0;i&lt;n;i++)
    {
        int MIN_index = i;
        for(int j=i;j&lt;n;j++)
            if(arr[MIN_index]&gt;arr[j]) MIN_index=j;
        swap(arr[MIN_index],arr[i]);
    }
}

</code></pre>
<h3 id="6快速排序">6.快速排序</h3>
<p>挖坑填坑的过程。</p>
<pre><code class="language-c++">void quiSort(int *arr,int l,int r)
{
    if(l&gt;=r) return;
    int base=arr[l];
    int i=l,j=r;
    while(i&lt;j)
    {
        while(arr[j]&gt;=base&amp;&amp;i&lt;j) j--;
        if(i&lt;j) arr[i++]=arr[j];
        while(arr[i]&lt;base&amp;&amp;i&lt;j) i++;
        if(i&lt;j) arr[j--]=arr[i];
    }
    arr[i]=base;
    quiSort(arr,l,i-1);
    quiSort(arr,i+1,r);
}

</code></pre>
<h3 id="7希尔排序">7.希尔排序</h3>
<p>希尔排序就是升级版的插入排序。</p>
<pre><code class="language-c++">void sheSort(int *arr,int n)
{
    int gap=n/2;
    while(gap&gt;=1)
    {
        for(int i=gap; i&lt;n; i++)
        {
            int j=i-gap;
            int tmp=arr[i];
            while(j&gt;=0&amp;&amp;tmp&lt;arr[j])
            {
                arr[j+gap]=arr[j];
                j-=gap;
            }
            arr[j+gap]=tmp;
        }
        gap/=2;
    }
}

</code></pre>
<h3 id="8堆排序">8.堆排序</h3>
<p>不断拿出堆顶结点然后调整大(小)顶堆的过程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【C++】没用的小知识]]></title>
        <id>https://cactusii.github.io/post/cmei-yong-de-xiao-zhi-shi/</id>
        <link href="https://cactusii.github.io/post/cmei-yong-de-xiao-zhi-shi/">
        </link>
        <updated>2020-09-21T14:42:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="c编译器">C++编译器</h2>
<p>C/C++常用的编译器是由GNU开发的GCC编译器。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【C++】面向对象基基基基础]]></title>
        <id>https://cactusii.github.io/post/cji-ji-ji-ji-chu-mian-xiang-dui-xiang/</id>
        <link href="https://cactusii.github.io/post/cji-ji-ji-ji-chu-mian-xiang-dui-xiang/">
        </link>
        <updated>2020-09-21T09:27:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1构造函数析构函数类和对象">1.构造函数&amp;析构函数（类和对象）</h2>
<h2 id="2基类派生类继承">2.基类&amp;派生类（继承）</h2>
<h2 id="3函数重载虚函数多态">3.函数重载&amp;虚函数（多态）</h2>
<h2 id="4抽象">4.抽象</h2>
<h2 id="5接口抽象类">5.接口（抽象类）</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浮点数的存储方法以及python的Decimal]]></title>
        <id>https://cactusii.github.io/post/fu-dian-shu-de-cun-chu-fang-fa-yi-ji-python-de-decimal/</id>
        <link href="https://cactusii.github.io/post/fu-dian-shu-de-cun-chu-fang-fa-yi-ji-python-de-decimal/">
        </link>
        <updated>2020-09-19T02:06:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="浮点数的存储方式">浮点数的存储方式</h2>
<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600483237666.jpg" alt="" loading="lazy"></figure>
<h2 id="decimaldecimal">decimal.Decimal</h2>
<p>python中的decimal.Decimal类型可以非常精确地存储在计算机中，其优于float类型。<br>
用法：</p>
<pre><code class="language-python">from decimal import Decimal

# 字符串/浮点数转换为Decimal
Decimal('1.11')
# &gt;&gt;Decimal('1.11')
Decimal(1.11)
# &gt;&gt;Decimal('1.1100000000000000976996261670137755572795867919921875')

# 四舍五入
Decimal('50.5679').quantize(Decimal('0.00'))
# &gt;&gt;Decimal('50.57')

# Decimal 结果转化为string
str(Decimal('3.40').quantize(Decimal('0.0')))
# &gt;&gt;'3.4'

</code></pre>
<p>将浮点数以二进制输出：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
	float fnum = 1;
	int i;
	int * p = (int *)&amp;fnum;//定义一个指向fnum的指针
        int x=0;//设置flag变量
	while (fnum != 0)//以0作为输入结束标志
	{
		printf(&quot;input a num: &quot;);
		x=scanf(&quot;%f&quot;, &amp;fnum);
                if(!x)//判断是否输入成功
                {
                       printf(&quot;wrong\n&quot;);
                       fflush(stdin);//清空输入流，不然会死循环
                       continue;
                }
		for (i = 31; i &gt;= 0; i--)
		{
                      /*将1左移i位，通过与运算判断第i位是否为1*/
                      printf(&quot;%d&quot;, (*p &amp; (1 &lt;&lt; i) ? 1: 0));
                      /*控制空格输入*/
                      if(i==31||i==23)
                           printf(&quot;  &quot;);
                      if(i==27||i==19||i==15||i==11||i==7||i==3)
                           printf(&quot; &quot;);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编译型、解释型语言]]></title>
        <id>https://cactusii.github.io/post/bian-yi-xing-jie-shi-xing-yu-yan/</id>
        <link href="https://cactusii.github.io/post/bian-yi-xing-jie-shi-xing-yu-yan/">
        </link>
        <updated>2020-09-16T12:02:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="编译型语言">编译型语言</h2>
<p>需要通过编译器将源代码编译成机器码，之后才能执行的语言。一般需经过编译、链接这两个步骤。编译时把源代码编译成机器码，链接时把各个模块的机器码和依赖库串联起来生成可执行文件。</p>
<p><strong>优点：</strong> 编译一次，运行时不需要编译，所以执行效率高，可以脱离语言环境独立运行（因为已经编译成了基于此机器系统的机器指令码）。大部分软件产品都是以目标程序形式发行给用户，不仅便于直接执行，而且又使得他人难以盗用其中的技术。</p>
<p><strong>缺点：</strong> 编译之后如果需要修改则需要再次编译，由于编译执行的语言直接跟CPU的指令集打交道，具有很强的指令依赖性和系统依赖性，因此在不同操作系统之间移植会出现问题，需要根据运行的操作系统环境编译不同的可执行文件。</p>
<p><strong>代表语言：</strong> C、C++、Pascal、Object-C</p>
<h2 id="解释型语言">解释型语言</h2>
<p>解释型语言的程序不需要编译，相比编译型语言省了道工序，解释型语言在运行程序时才逐行进行翻译。（边执行边翻译）</p>
<p><strong>优点：</strong> 有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。</p>
<p><strong>缺点：</strong> 每次运行的时候都要解释一遍，因此运行速度会稍慢。</p>
<p><strong>代表语言：</strong> JavaScript、Python、Erlang、PHP、Perl、Ruby</p>
<p>脚本语言是解释型语言。</p>
<h2 id="混合型语言">混合型语言</h2>
<p>混合型语言在编译的时候不是直接编译成机器码，而是中间码。<br>
例如java将程序翻译成一种中间代码字节码，可以被java解释器解释的独立于平台的代码。通过解释器，每条java字节指令被分析，然后运行在计算机上。只需编译一次，程序运行时解释执行。</p>
<p>可以把java字节码看作运行在java虚拟机上的机器代码指令。每种java解释器，不管是java 开发工具还是可以运行java小应用程序的web浏览器，都是一种java VM的实例，java VM也可以由硬件实现。</p>
<p>我们都知道java语言一个非常重要的特点是与平台无关性，而java VM是实现这一特点的关键。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[近世代数基础]]></title>
        <id>https://cactusii.github.io/post/jin-shi-dai-shu-ji-chu/</id>
        <link href="https://cactusii.github.io/post/jin-shi-dai-shu-ji-chu/">
        </link>
        <updated>2020-09-16T07:42:13.000Z</updated>
        <content type="html"><![CDATA[<p>非负整数（自然数）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span><br>
正整数集：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mo>+</mo></msup><mi mathvariant="normal">/</mi><msup><mi>N</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">N^{+}/N^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span><br>
整数集：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span><br>
有理数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span><br>
实数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span></p>
<p><strong>半群：</strong> 有一个集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>，还有一个二元运算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo separator="true">⋅</mo></mrow><annotation encoding="application/x-tex">·</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mpunct">⋅</span></span></span></span>（满足结合律），二者形成的代数结构叫做半群，记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>S</mi><mo separator="true">,</mo><mo separator="true">⋅</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(S,·)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">)</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>。</p>
<blockquote>
<p>例如实数集关于加法，构成一个半群<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo separator="true">,</mo><mo>+</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(R,+)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mclose">)</span></span></span></span>。</p>
</blockquote>
<p><strong>交换半群：</strong> 满足交换律的半群。</p>
<p><strong>含幺半群：</strong> 含有幺元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span>（单位元，对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">x∈S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>e</mi><mo>=</mo><mi>e</mi><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">xe=ex=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>）的半群。（例如在乘法运算e=1，加法中e=0）</p>
<p><strong>群：</strong> 设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>为含幺半群，如果对于任意<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">x∈S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的逆元素存在，则S是一个群。(逆元素：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mi>x</mi><mo>=</mo><mi>x</mi><mi>y</mi><mo>=</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">yx=xy=e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的逆元素，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>x</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">y=x^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>)</p>
<blockquote>
<p>例如，所有不等于零的实数，关于乘法构成一个群。</p>
</blockquote>
<p><strong>阿贝尔群（交换群）：</strong> 满足交换律的群。</p>
<p><strong>有限群：</strong> 元素个数有限，其中元素个数称为阶。</p>
<p><img src="https://cactusii.github.io//post-images/1600244733330.png" alt="" loading="lazy"><br>
<img src="https://cactusii.github.io//post-images/1600244739970.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[秘密共享算法]]></title>
        <id>https://cactusii.github.io/post/mi-mi-gong-xiang-suan-fa/</id>
        <link href="https://cactusii.github.io/post/mi-mi-gong-xiang-suan-fa/">
        </link>
        <updated>2020-09-16T00:54:07.000Z</updated>
        <content type="html"><![CDATA[<p>🐕</p>
<h2 id="1秘密共享算法的概念">1.秘密共享算法的概念</h2>
<p>(k,n)门限秘密标识把秘密信息分成n份无意义的子秘密，只有拥有至少k份子秘密才能恢复秘密信息。</p>
<h2 id="2shamir算法">2.shamir算法</h2>
<p>shamir(k,n)门限方案是通过构造一个k-1次多项式，并将需共享的秘密作为该多项的常数项，将秘密分成n部分分别给n个参与者，使k个参与者联合可恢复秘密，但少于k个参与者不能得到共享秘密的任何信息。</p>
<h3 id="21原理">2.1原理</h3>
<p><strong>加密过程：</strong><br>
假设有秘密<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>，任取随机数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,...,a_{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>。令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>=</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">a_0=S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>，构造多项式：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>a</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mi>x</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">f(x)=a_0+a_1x+a_2x^2+...+a_{k-1}x^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.964108em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0574389999999998em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><br>
其中所有的运算都在有限域F中进行。<br>
任取n个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1,...,x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别带入多项式得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>f</mi><mo>(</mo><msub><mi>x</mi><mi>n</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x_1),...,f(x_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。<br>
将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>f</mi><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>)</mo><mo>)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mo>(</mo><msub><mi>x</mi><mi>n</mi></msub><mo separator="true">,</mo><mi>f</mi><mo>(</mo><msub><mi>x</mi><mi>n</mi></msub><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1,f(x_1)),...,(x_n,f(x_n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>分别存储在n个服务器上。</p>
<p><strong>解密过程：</strong></p>
<figure data-type="image" tabindex="1"><img src="https://cactusii.github.io//post-images/1600245240748.png" alt="" loading="lazy"></figure>
<p>虽然多项式地求解比较好理解，但是程序应该怎么写呢？<br>
这里用到了<strong>拉格朗日插值公式</strong>去求解多项式系数<br>
参考<a href="https://www.zhihu.com/question/58333118">拉格朗日插值</a><br>
<img src="https://cactusii.github.io//post-images/1600486914914.png" alt="" loading="lazy"></p>
<pre><code class="language-python"># Implementation of Shamir Secret Sharing Scheme 
# python3
   
import random 
from math import ceil 
from decimal import *
   
global field_size 
field_size = 10**5
   
def reconstructSecret(shares): 
      
    # Combines shares using  
    # Lagranges interpolation.  
    # Shares is an array of shares 
    # being combined 
    sums, prod_arr = 0, [] 
      
    for j in range(len(shares)): 
        xj, yj = shares[j][0],shares[j][1] 
        prod = Decimal(1) 
          
        for i in range(len(shares)): 
            xi = shares[i][0] 
            if i != j:
                prod *= Decimal(Decimal(xi)/(xi-xj)) 
                  
        prod *= yj 
        sums += Decimal(prod) 
          
    return int(round(Decimal(sums),0)) 
   
def polynom(x,coeff): 

    return sum([x**(len(coeff)-i-1) * coeff[i] for i in range(len(coeff))]) 
   
def coeff(t,secret): 

    coeff = [random.randrange(0, field_size) for _ in range(t-1)] 
    coeff.append(secret) 
    return coeff 
   
def generateShares(n,m,secret): 
      
    # Split secret using SSS into 
    # n shares with threshold m 
    cfs = coeff(m,secret) 
    shares = [] 
      
    for i in range(1,n+1): 
        r = random.randrange(1, field_size) 
        shares.append([r, polynom(r,cfs)]) 
      
    return shares 
  
  
# Driver code  
if __name__ == '__main__': 
      
    # (3,5) sharing scheme
    k,n = 3, 5
    secret = 1234
    print('Original Secret:', secret) 

    shares = generateShares(n, k, secret)
    print('Phase I: Generation of shares')
    print('\nShares:', shares)
    # Phase II: Secret Reconstruction 
    # Picking t shares randomly for 
    # reconstruction 
    pool = random.sample(shares, k)
    print('\nCombining shares:', pool) 
    print(&quot;Reconstructed secret:&quot;, reconstructSecret(pool)) 

</code></pre>
]]></content>
    </entry>
</feed>